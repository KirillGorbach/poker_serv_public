№1
	Активность регистрации
Смотрит в SharedPreferences поля "имя" и "пароль".
а)Поля не заполнены => фрагмент регистрации. Пользователь вводит
имя и пароль, выбирает себе аватарку.
	Важно: для ввода имени-пароля нужно (неужели!) клавиатура.
	Стандартная гугловская- зашквар, реальные пацаны делают сами:
	https://m.habr.com/ru/post/322070/
	Также хотелось бы красиво оформить выбр картинки. Я вижу это так:
	<кнопка "предыдущая аватарка"> [само изображение] <кнопка "следуюшая аватарка">
	После этого отправляется запрос на регистрацию
	(для этого нужен порядковый номер картинки, новое имя и пароль) 
	Вид данных запроса:
	"registration", { name:"Kirill" , password:"qwerty" , picture:1 }
	//"registration" - это тег запроса (см. socket.io)
	
	Возможный ответ
	"registration" +
	а){
		is_reg: true
		,player: {}
	  }
	б){
		is_reg: false
		,player: {{ id: 2, name: "Kirill", password: "admin", money: 100, picture: 1 }}
	  }
	
	Важно: регистрация может не пройти- ник занят. Тогда нужно показать 
	тост об этом и вернуть на заполнение этих полей.
	Когда сервер одобрит регистрацию, он пришлёт все данные нового
	пользователя (в том числе, картинку, начальный игровой счёт и м/б
	уровень *пока не добавлено*)
	Важно: большиство ответов сервера имеют тот же тег, что и запрос
	клиента. Именно поэтому здесь сервер ответит
	"registration",
	{ id: 2, name: "Kirill", password: "admin", money: 100, picture: 1 }
	Картинку нужно ввести ту, что пришла с сервера - иначе ошибка на
	сервере будет незаметна.
	
	
б)Поля заполнены - отправляем на сервер запрос на аутентификацию. Как и
при регистрации, все данные о игроке берутся с сервера, иначе будет
возможность расхождения данных на сервере и клиенте.
	Пример запроса: "auth", { name:"Kirill" , password:"qwerty" }
	Ответ: "registration", { id: 2, name: "Kirill", password: "admin",
	money: 100, picture: 1 }

Так или иначе получив данные, активность кладёт их в SharedPreference
и запускает активность меню (без всяких интентов)

№2
	Активность меню
Активность меню берёт данные и игроке из SharedPreferences и
высвечивает на экране.
Когда пользователь жмёт на кнопку "выбрать лобби", на сервер
отправляется запрос "getlobbies" без параметров.
В ответ прихолит JSON со свежим списком комнат. Вот так:

TestApplication app = (TestApplication)getActivity().getApplication();
mSocket = app.getSocket();
mSocket.on("getlobbies", new Emitter.Listener() {
	@Override
    public void call(Object... args) {
        String data = (String) args[0];
        AllRooms rooms;
        rooms = new Gson().fromJson(data, AllRooms.class);
		//операции получения полей объекта rooms
    }
});

Где класс AllRooms:

public class AllRooms implements Serializable {
    private List<Room> rooms;
	public class Room implements Serializable {
		private Integer length;
		private String name;
	}
}

По сути, это просто обёртка для удобного общения с JSON.
В ListView комнат ставятся параметры всех лобби.
При нажатии на элемент ListView должна вызываться активность игры с
параметром "имя лобби".
Этот момент очень важен: до этого момента не было разницы, с какого
сокета отправлять запросы. При входе же в комнату сервер "привязывает"
имя соединения к сокету клиента.

№3
	Игровая активность
Перед отрисовкой игрового фрагмента отображается фрагмент загрузки.
В это время на сервер отправляется запрос "enterlobby", с JSON-строкой
следующего типа (я ещё не написал сериализуемый объект для этой цели):
"enterlobby", {name:"Kirill" , lobbyname:"selected_room_name"}  
//тупа "вечер в хату"
На что сервер кинет JSON 
"enterlobby", 
{
	didenter:true/false
	,lobbyinfo:{
			bank: //состояние банка
            ,rate: //ставка в этой комнате
            ,isgamerunning: //идёт ли здесь игра
            ,name: //имя лобби
            ,cards: {
					deck: [ int, int, int, int, int] //карты на столе
					,players: [	{ //игрок-его карты
									playername: "Ololoshka1"
									,cards: [int, int]
								}
								,{
									playername: "Ololoshka2"
									,cards: [int, int]
								}]
				}
            ,playersingame: [	{ //игрок-его параметры
									playername: "Ololoshka1"
									,money: 100
									,picture: 2
								}
								,{
									playername: "Ololoshka2"
									,money: 140
									,picture: 1
								}]
			//при входе в лобби игрок видит как тех, кто играет, так и
			//тех, кто не играет
            ,allplayers: [	{ //игрок-его параметры
									playername: "Ololoshka1"
									,money: 100
									,picture: 2
								}
								,{
									playername: "Ololoshka2"
									,money: 140
									,picture: 1
								}
								,{
									playername: "Ololoshka3"
									,money: 0
									,picture: 2
								}]
        }
}
Этого достаточно, чтобы отобразить игровой процесс.

Остальным приходит уведомление о новом игроке:
"newplayerjoinedlobby",
{ 
	id: 1
	,name: 'Kirill1'
	,money: 90
	,picture: 1 
}

Важно: игроков расставитьпо кругу в порядке их описания в свойстве
allplayers, но чтобы при этом сам игрок сидел посередине. 

Когда текущий раунд заверщён, автоматически начинается новая игра, в
которую автоматически добавляются все присутствующие.
С началом игры приходит JSON:
"game starts!",
{ roomparams:
   { bank: 0,				//проверка, что банк пустой
     rate: 10,				//начальная ставка
     isgamerunning: true, 	//слегка избыточный флаг начала игры
     name: 'room1',
     cards: { 
			deck: [ 202, 204, 407, 302, 205 ], //на столе
			players: [ 
				{ playername: 'Kirill0', cards: [ 103, 208 ] },		
				//у игрока с именем 'Kirill0'
				{ playername: 'Kirill1', cards: [ 114, 203 ] } ] 	
				//у игрока с именем 'Kirill1'
			},
     playersingame: [ 
			{ name: 'Kirill0', money: 100, picture: 1 },
			{ name: 'Kirill1', money: 100, picture: 1 } ],
     allplayers: [ 
			{ name: 'Kirill0', money: 100, picture: 1 },
			{ name: 'Kirill1', money: 100, picture: 1 } ] },
  lead: 'Kirill0' //ведущий игрок
}

В ответ на это клиент должен найти свои карты, вычислить код своей
комбинации (самой сильной комбинации из своих карт и карт на столе),
и отправить на сервер такое сообщение:
"myhandpower",
{ 
	name: 'Kirill0'
	,power: 10029320202 
} 
Ответа не последует.
Сервер в любой момент до конца игры готов принять это сообщение. Сила
руки будет поставлена в соответствие данному игроку.

Далее - список игровых сообщений.
Важно: состояние денег игроков изменяется сервером, но изменения должны
дублироваться на клиенте.
Иначе будет слишком много информации.
При действии "ва-банк" или когда игрок ставит все свои деньги, делая
"чек" или "рейз", игрок переходит в фазу "ready_to_finish".
При следующей смене раунда такой игрок становится неактивным, но если
все игроки "ready_to_finish" (или все, кроме одного),
то производится завершение игры.
"Фолд" просто делает игрока неактивным. Это может стать причиной
завершения игры.
Каждый запрос адресован конкретному лобби с конкретной игрой. Это важно.
Всего действует несколько лоббей одновременно.



	"Чек"
Важно: клиент не должен выполять действие, если денег не хватает.
Сервер не упадёт, но деньги игрока станут отрицательными. Это не
отлавливается на сервере.
Отправляем:
"check",
	{
		name: 'Kirill1'
		,lobbyname: 'room1'
	}
Ответ игроку:
"youcheck",
	{ 
		flag: true				//флаг успешности
		,newlead: 'Kirill1' 
	}
Всем приходит:
"playercheck",
	{ 
		name: 'Kirill0'
		,newlead: 'Kirill1' 
	}
	

	"Рейз"
Важно: клиент не должен выполять действие, если денег не хватает;
ставка не должна быть меньше текущей.
Рейз изменяет ставку в игре. Проверки нет (пока).
Отправляем:
"raise",
	{
		name: 'Kirill1'
		,lobbyname: 'room1'
		,rate: 10
	}
Ответ игроку:
"youraise",
	{ 
		flag: true				//флаг успешности
		,newlead: 'Kirill1' 
	}
Всем приходит:
"playerraise",
	{ 
		name: 'Kirill0'
		,newlead: 'Kirill1'
		,rate: 10
	}
	
	
	"Фолд"
Тут просто. Игрок выходит из списка активных,
но остаётся висеть в лобби.
Отправляем:
"fold",
	{
		name: 'Kirill1'
		,lobbyname: 'room1'
	}
Ответ игроку:
"youfold",
	{ 
		flag: true				//флаг успешности
		,newlead: 'Kirill1' 
	}
Всем приходит:
"playerfold",
	{ 
		name: 'Kirill0'
		,newlead: 'Kirill1'
	}
	
	
	"Ва-банк"
Игрок выходит из числа активных, все деньги уходят в банк.
Отправляем:
"allin",
	{
		name: 'Kirill1'
		,lobbyname: 'room1'
	}
Ответ игроку:
"allin",
	{ 
		flag: true				//флаг успешности
		,newlead: 'Kirill1' 
	}
Всем приходит:
"playerallin",
	{ 
		name: 'Kirill0'
		,newlead: 'Kirill1'
	}
	
	
	"Выйти из лобби"
Игрок выходит из лобби. Совсем.
Игрока исключают из списка активных игроков и полного списка.
Важно:
	игрок может покинуть лобби в любой момент,
	независимо от порядка хода
Это действие может привести к завершению игры.
Отправляем:
"leavelobby",
	{
		name: 'Kirill1'
		,lobbyname: 'room1'
	}
Ответ игроку:
"youleft",,
	{ 
		money: 60 	//игроку сообщается актуальная сумма его денег
	}
Всем приходит:
"playerleft",
	{ 
		name: 'Kirill0'
		,newlead: 'Kirill1'
	}
	
	
Интересное: завершение игры.
В один прекрасный момент с сервера приходит сообщение:
"endgame",
	{ 
		win_val: 20
		,winners: [
				"Kirill1"
			] 
	}
Где win_val - сумма, которая передаётся победителям. Далее идёт список
победителей.
Важно: если в банке нет денег, то придёт { win_val: null, winners: [] }, 
null надо отловить.

Сразу после конца игры начинается новая (если игроков хватает).

Для тестирования соединения с сервером существует специальный
канал - "yess". На такой запрос сервер вернёт то, что ему послали.
